//! Generated Worker message protocol
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! Maps Erlang messages ↔ Rust types with full codec support

extern crate alloc;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use alloc::format;
use crate::term::{TermValue};
use crate::atom::AtomTableOps;
use crate::generated::atoms::*;

/// Worker actor messages (auto-generated from ontology)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum WorkerMsg {
    /// Inc(by: i64) -> reply: i64
    /// Increment counter by given amount, return new value
    Inc(i64),

    /// Get() -> reply: i64
    /// Return current counter value
    Get,
}

/// Worker reply types (auto-generated from ontology)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum WorkerReply {
    /// Inc success: new counter value
    IncReply(i64),

    /// Get success: counter value
    GetReply(i64),
}

/// Codec: Erlang term → WorkerMsg
/// Maps `{inc, N}` and `get` to Rust enum
pub fn decode_worker_msg<T: AtomTableOps>(
    term: &TermValue,
    table: &T,
) -> Result<WorkerMsg, String> {
    // Pattern: {inc, N} where N is integer
    if let Some(elems) = term.as_tuple() {
        if elems.len() == 2 {
            if let (Some(tag), Some(n)) = (elems[0].as_atom(), elems[1].as_int()) {
                let inc_atom = table.ensure_atom_str(ATOM_INC)
                    .map_err(|_| "atom table error: inc".to_string())?;

                if tag == inc_atom {
                    return Ok(WorkerMsg::Inc(n as i64));
                }
            }
        }
    }

    // Pattern: atom `get`
    if let Some(tag) = term.as_atom() {
        let get_atom = table.ensure_atom_str(ATOM_GET)
            .map_err(|_| "atom table error: get".to_string())?;

        if tag == get_atom {
            return Ok(WorkerMsg::Get);
        }
    }

    Err(format!("Cannot decode WorkerMsg from {:?}", term))
}

/// Codec: WorkerReply → Erlang term
/// Maps Rust replies back to atoms/tuples for AtomVM
pub fn encode_worker_reply<T: AtomTableOps>(
    reply: &WorkerReply,
    table: &T,
) -> Result<TermValue, String> {
    match reply {
        WorkerReply::IncReply(value) => {
            // Reply: {ok, Value}
            let ok_atom = table.ensure_atom_str(ATOM_OK)
                .map_err(|_| "atom table error: ok".to_string())?;
            Ok(TermValue::tuple(alloc::vec![
                TermValue::Atom(ok_atom),
                TermValue::int(*value as i32),
            ]))
        }
        WorkerReply::GetReply(value) => {
            // Reply: {ok, Value}
            let ok_atom = table.ensure_atom_str(ATOM_OK)
                .map_err(|_| "atom table error: ok".to_string())?;
            Ok(TermValue::tuple(alloc::vec![
                TermValue::Atom(ok_atom),
                TermValue::int(*value as i32),
            ]))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::testing::*;

    #[test]
    fn test_decode_inc_msg() {
        let table = MockAtomTable::new();

        // Build term: {inc, 42}
        let inc_atom = table.ensure_atom_str(ATOM_INC).unwrap();
        let term = TermValue::tuple(alloc::vec![
            TermValue::Atom(inc_atom),
            TermValue::int(42),
        ]);

        let msg = decode_worker_msg(&term, &table);
        assert!(msg.is_ok());

        if let Ok(WorkerMsg::Inc(n)) = msg {
            assert_eq!(n, 42);
        }
    }

    #[test]
    fn test_decode_get_msg() {
        let table = MockAtomTable::new();

        // Build term: atom `get`
        let get_atom = table.ensure_atom_str(ATOM_GET).unwrap();
        let term = TermValue::Atom(get_atom);

        let msg = decode_worker_msg(&term, &table);
        assert!(msg.is_ok());
        assert!(matches!(msg.unwrap(), WorkerMsg::Get));
    }

    #[test]
    fn test_encode_inc_reply() {
        let table = MockAtomTable::new();

        let reply = WorkerReply::IncReply(99);
        let term = encode_worker_reply(&reply, &table);
        assert!(term.is_ok());

        let t = term.unwrap();
        assert!(t.as_tuple().is_some());
        assert_eq!(t.as_tuple().unwrap().len(), 2);
    }

    #[test]
    fn test_encode_get_reply() {
        let table = MockAtomTable::new();

        let reply = WorkerReply::GetReply(42);
        let term = encode_worker_reply(&reply, &table);
        assert!(term.is_ok());

        let t = term.unwrap();
        assert!(t.as_tuple().is_some());
    }

    #[test]
    fn test_roundtrip_inc() {
        let table = MockAtomTable::new();

        // Create message
        let inc_atom = table.ensure_atom_str(ATOM_INC).unwrap();
        let msg_term = TermValue::tuple(alloc::vec![
            TermValue::Atom(inc_atom),
            TermValue::int(5),
        ]);

        // Decode
        let msg = decode_worker_msg(&msg_term, &table).unwrap();
        assert_eq!(msg, WorkerMsg::Inc(5));
    }

    #[test]
    fn test_roundtrip_get() {
        let table = MockAtomTable::new();

        // Create message
        let get_atom = table.ensure_atom_str(ATOM_GET).unwrap();
        let msg_term = TermValue::Atom(get_atom);

        // Decode
        let msg = decode_worker_msg(&msg_term, &table).unwrap();
        assert_eq!(msg, WorkerMsg::Get);
    }
}
