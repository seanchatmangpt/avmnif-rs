//! Generated Atom Table
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! Shows what atoms exist in the Worker protocol
//!
//! Stable atom IDs for all atoms used in the Worker protocol
//! These IDs must match exactly between Rust and Erlang

extern crate alloc;
use alloc::string::String;
use alloc::format;
use crate::atom::AtomIndex;

/// Atom: "worker"
pub const ATOM_WORKER: &str = "worker";

/// Atom: "inc"
pub const ATOM_INC: &str = "inc";

/// Atom: "get"
pub const ATOM_GET: &str = "get";

/// Atom: "ok"
pub const ATOM_OK: &str = "ok";

/// Atom: "error"
pub const ATOM_ERROR: &str = "error";

/// Atom: "badarg"
pub const ATOM_BADARG: &str = "badarg";

/// Atom: "internal_error"
pub const ATOM_INTERNAL_ERROR: &str = "internal_error";

/// Initialize all atoms in the table
/// Call this once at startup to ensure stable IDs
pub fn init_atoms<T: crate::atom::AtomTableOps>(table: &T) -> Result<(), String> {
    let _ = table.ensure_atom_str(ATOM_WORKER)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_INC)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_GET)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_OK)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_ERROR)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_BADARG)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    let _ = table.ensure_atom_str(ATOM_INTERNAL_ERROR)
        .map_err(|e| format!("Failed to ensure atom: {:?}", e))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::testing::*;

    #[test]
    fn test_init_atoms() {
        let table = MockAtomTable::new();
        let result = init_atoms(&table);
        assert!(result.is_ok());
    }
}
