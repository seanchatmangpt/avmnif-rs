// Generated by ggen from example-math-nifs.ttl
// NIF function implementations for math operations
// DO NOT EDIT - This file is auto-generated from RDF ontologies
// Generated at: 2026-01-01T03:05:18.749273

use crate::{
    atom::AtomTableOps,
    context::Context,
    term::{Term, TermValue, NifError, NifResult},
};

/// Add
///
/// Add two integers with overflow checking
pub fn nif_add(
    ctx: &mut Context,
    args: &[Term],
) -> NifResult<Term> {
    if args.len() != 2 {
        return Err(NifError::BadArity);
    }

    let a = args[0].to_value()?.as_int().ok_or(NifError::BadArg)?;
    let b = args[1].to_value()?.as_int().ok_or(NifError::BadArg)?;

    let sum = a.checked_add(b).ok_or(NifError::OutOfMemory)?;
    let result = TermValue::int(sum);

    unsafe {
        let heap = &mut *(ctx as *mut Context as *mut crate::term::Heap);
        Ok(Term::from_value(result, heap)?)
    }
}

/// Multiply
///
/// Multiply two integers with overflow checking
pub fn nif_multiply(
    ctx: &mut Context,
    args: &[Term],
) -> NifResult<Term> {
    if args.len() != 2 {
        return Err(NifError::BadArity);
    }

    let x = args[0].to_value()?.as_int().ok_or(NifError::BadArg)?;
    let y = args[1].to_value()?.as_int().ok_or(NifError::BadArg)?;

    let product = x.checked_mul(y).ok_or(NifError::OutOfMemory)?;
    let result = TermValue::int(product);

    unsafe {
        let heap = &mut *(ctx as *mut Context as *mut crate::term::Heap);
        Ok(Term::from_value(result, heap)?)
    }
}

/// Is Even
///
/// Check if integer is even, return true or false atom
pub fn nif_is_even<T: AtomTableOps>(
    ctx: &mut Context,
    args: &[Term],
    table: &T,
) -> NifResult<Term> {
    if args.len() != 1 {
        return Err(NifError::BadArity);
    }

    let n = args[0].to_value()?.as_int().ok_or(NifError::BadArg)?;
    let is_even = n % 2 == 0;

    let atom_name = if is_even { "true" } else { "false" };
    let atom_idx = table.ensure_atom_str(atom_name)
        .map_err(|_| NifError::OutOfMemory)?;
    let result = TermValue::Atom(atom_idx);

    unsafe {
        let heap = &mut *(ctx as *mut Context as *mut crate::term::Heap);
        Ok(Term::from_value(result, heap)?)
    }
}

/// List Sum
///
/// Sum all integers in a list with overflow checking
pub fn nif_list_sum(
    ctx: &mut Context,
    args: &[Term],
) -> NifResult<Term> {
    if args.len() != 1 {
        return Err(NifError::BadArity);
    }

    let list_term = args[0].to_value()?;
    let list_vec = list_term.list_to_vec();

    let sum = list_vec.iter().try_fold(0i32, |acc, term| {
        let n = term.as_int().ok_or(NifError::BadArg)?;
        acc.checked_add(n).ok_or(NifError::OutOfMemory)
    })?;

    let result = TermValue::int(sum);
    unsafe {
        let heap = &mut *(ctx as *mut Context as *mut crate::term::Heap);
        Ok(Term::from_value(result, heap)?)
    }
}

/// Tuple to List
///
/// Convert a tuple to a list with the same elements
pub fn nif_tuple_to_list(
    ctx: &mut Context,
    args: &[Term],
) -> NifResult<Term> {
    if args.len() != 1 {
        return Err(NifError::BadArity);
    }

    let tuple_term = args[0].to_value()?;
    let elements = tuple_term.as_tuple().ok_or(NifError::BadArg)?;

    let result = TermValue::list(elements.to_vec());
    unsafe {
        let heap = &mut *(ctx as *mut Context as *mut crate::term::Heap);
        Ok(Term::from_value(result, heap)?)
    }
}

