//! Generated Worker NIF dispatcher
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! Receives messages from AtomVM, dispatches to Rust handlers, returns results

extern crate alloc;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use crate::term::TermValue;
use crate::atom::AtomTableOps;
use crate::generated::worker_protocol::*;

/// Worker actor state (holds data across messages)
#[derive(Debug, Clone)]
pub struct WorkerState {
    pub count: i64,
}

impl WorkerState {
    /// Create initial state
    pub fn new() -> Self {
        WorkerState { count: 0 }
    }

    /// Handler: inc(by)
    pub fn handle_inc(&mut self, by: i64) -> i64 {
        self.count += by;
        self.count
    }

    /// Handler: get()
    pub fn handle_get(&self) -> i64 {
        self.count
    }
}

impl Default for WorkerState {
    fn default() -> Self {
        Self::new()
    }
}

/// Main dispatcher: routes message to handler
///
/// Called from AtomVM NIF:
///   kgc_nif:dispatch(ActorId, Message) -> Reply
///
/// Receives decoded WorkerMsg, executes handler, returns encoded reply
pub fn dispatch(
    state: &mut WorkerState,
    msg: WorkerMsg,
    _table: &impl AtomTableOps,
) -> Result<WorkerReply, String> {
    match msg {
        WorkerMsg::Inc(by) => {
            let new_count = state.handle_inc(by);
            Ok(WorkerReply::IncReply(new_count))
        }
        WorkerMsg::Get => {
            let count = state.handle_get();
            Ok(WorkerReply::GetReply(count))
        }
    }
}

/// Full message handling pipeline:
/// 1. Decode term → WorkerMsg
/// 2. Dispatch to handler
/// 3. Encode reply → term
pub fn handle_term_message(
    state: &mut WorkerState,
    msg_term: &TermValue,
    table: &impl AtomTableOps,
) -> Result<TermValue, TermValue> {
    // Decode message
    let msg = match decode_worker_msg(msg_term, table) {
        Ok(m) => m,
        Err(_e) => {
            // Return error term
            return Err(TermValue::Invalid);
        }
    };

    // Dispatch to handler
    let reply = match dispatch(state, msg, table) {
        Ok(r) => r,
        Err(_) => {
            return Err(TermValue::Invalid);
        }
    };

    // Encode reply
    encode_worker_reply(&reply, table)
        .map_err(|_| TermValue::Invalid)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::testing::*;

    #[test]
    fn test_worker_state_creation() {
        let state = WorkerState::new();
        assert_eq!(state.count, 0);
    }

    #[test]
    fn test_worker_handle_inc() {
        let mut state = WorkerState::new();

        let new_count = state.handle_inc(5);
        assert_eq!(new_count, 5);
        assert_eq!(state.count, 5);
    }

    #[test]
    fn test_worker_handle_get() {
        let mut state = WorkerState::new();
        state.count = 42;

        let count = state.handle_get();
        assert_eq!(count, 42);
    }

    #[test]
    fn test_worker_inc_then_get() {
        let mut state = WorkerState::new();

        state.handle_inc(10);
        let count = state.handle_get();

        assert_eq!(count, 10);
    }

    #[test]
    fn test_dispatch_inc() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        let msg = WorkerMsg::Inc(7);
        let result = dispatch(&mut state, msg, &table);

        assert!(result.is_ok());
        assert_eq!(state.count, 7);

        if let Ok(WorkerReply::IncReply(new_count)) = result {
            assert_eq!(new_count, 7);
        }
    }

    #[test]
    fn test_dispatch_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();
        state.count = 99;

        let msg = WorkerMsg::Get;
        let result = dispatch(&mut state, msg, &table);

        assert!(result.is_ok());

        if let Ok(WorkerReply::GetReply(count)) = result {
            assert_eq!(count, 99);
        }
    }

    #[test]
    fn test_handle_term_message_inc() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        // Build term: {inc, 5}
        let inc_atom = table.ensure_atom_str("inc").unwrap();
        let msg_term = TermValue::tuple(alloc::vec![
            TermValue::Atom(inc_atom),
            TermValue::int(5),
        ]);

        let result = handle_term_message(&mut state, &msg_term, &table);
        assert!(result.is_ok());
        assert_eq!(state.count, 5);
    }

    #[test]
    fn test_handle_term_message_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();
        state.count = 42;

        // Build term: atom `get`
        let get_atom = table.ensure_atom_str("get").unwrap();
        let msg_term = TermValue::Atom(get_atom);

        let result = handle_term_message(&mut state, &msg_term, &table);
        assert!(result.is_ok());
    }

    #[test]
    fn test_multi_hop_inc_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        // Simulate 5 boundary crossings (Rust → AtomVM → Rust)
        for i in 1..=5 {
            let inc_atom = table.ensure_atom_str("inc").unwrap();
            let msg_term = TermValue::tuple(alloc::vec![
                TermValue::Atom(inc_atom),
                TermValue::int(i),
            ]);

            let result = handle_term_message(&mut state, &msg_term, &table);
            assert!(result.is_ok(), "Failed at hop {}", i);
        }

        // Verify final state
        assert_eq!(state.count, 1 + 2 + 3 + 4 + 5); // 15
    }

    #[test]
    fn test_boundary_crossing_determinism() {
        // Proves: same message sequence → same result (always)
        let table = MockAtomTable::new();

        // Run 1
        let mut state1 = WorkerState::new();
        for i in 1..=10 {
            let inc_atom = table.ensure_atom_str("inc").unwrap();
            let msg_term = TermValue::tuple(alloc::vec![
                TermValue::Atom(inc_atom),
                TermValue::int(i),
            ]);
            let _ = handle_term_message(&mut state1, &msg_term, &table);
        }

        // Run 2: identical sequence
        let mut state2 = WorkerState::new();
        for i in 1..=10 {
            let inc_atom = table.ensure_atom_str("inc").unwrap();
            let msg_term = TermValue::tuple(alloc::vec![
                TermValue::Atom(inc_atom),
                TermValue::int(i),
            ]);
            let _ = handle_term_message(&mut state2, &msg_term, &table);
        }

        // Results must be identical
        assert_eq!(state1.count, state2.count);
        assert_eq!(state1.count, 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10); // 55
    }
}
