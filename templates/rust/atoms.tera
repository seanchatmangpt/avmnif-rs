//! Generated Atom Table
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! DO NOT EDIT: changes will be overwritten
//!
//! Stable atom IDs for all atoms used in the Worker protocol
//! These IDs must match exactly between Rust and Erlang

use avmnif::atom::AtomIndex;

/// Atom: "worker"
pub const ATOM_WORKER: &str = "worker";

/// Atom: "inc"
pub const ATOM_INC: &str = "inc";

/// Atom: "get"
pub const ATOM_GET: &str = "get";

/// Atom: "ok"
pub const ATOM_OK: &str = "ok";

/// Atom: "error"
pub const ATOM_ERROR: &str = "error";

/// Atom: "badarg"
pub const ATOM_BADARG: &str = "badarg";

/// Atom: "internal_error"
pub const ATOM_INTERNAL_ERROR: &str = "internal_error";

/// Initialize all atoms in the table
/// Call this once at startup to ensure stable IDs
pub fn init_atoms<T: avmnif::atom::AtomTableOps>(table: &T) -> Result<(), String> {
    let _ = table.ensure_atom_str(ATOM_WORKER)?;
    let _ = table.ensure_atom_str(ATOM_INC)?;
    let _ = table.ensure_atom_str(ATOM_GET)?;
    let _ = table.ensure_atom_str(ATOM_OK)?;
    let _ = table.ensure_atom_str(ATOM_ERROR)?;
    let _ = table.ensure_atom_str(ATOM_BADARG)?;
    let _ = table.ensure_atom_str(ATOM_INTERNAL_ERROR)?;
    Ok(())
}

/// Atom IDs (deterministic indices)
pub struct AtomIds {
    pub worker: AtomIndex,
    pub inc: AtomIndex,
    pub get: AtomIndex,
    pub ok: AtomIndex,
    pub error: AtomIndex,
    pub badarg: AtomIndex,
    pub internal_error: AtomIndex,
}

impl AtomIds {
    /// Load all atom IDs from the table
    /// Must call init_atoms() first to ensure atoms exist
    pub fn load<T: avmnif::atom::AtomTableOps>(table: &T) -> Result<Self, String> {
        Ok(AtomIds {
            worker: table.ensure_atom_str(ATOM_WORKER)?,
            inc: table.ensure_atom_str(ATOM_INC)?,
            get: table.ensure_atom_str(ATOM_GET)?,
            ok: table.ensure_atom_str(ATOM_OK)?,
            error: table.ensure_atom_str(ATOM_ERROR)?,
            badarg: table.ensure_atom_str(ATOM_BADARG)?,
            internal_error: table.ensure_atom_str(ATOM_INTERNAL_ERROR)?,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use avmnif::testing::*;

    #[test]
    fn test_init_atoms() {
        let table = MockAtomTable::new();
        let result = init_atoms(&table);
        assert!(result.is_ok());
    }

    #[test]
    fn test_load_atom_ids() {
        let table = MockAtomTable::new();
        let _ = init_atoms(&table);

        let ids = AtomIds::load(&table);
        assert!(ids.is_ok());

        let ids = ids.unwrap();
        assert_ne!(ids.worker, ids.inc);
        assert_ne!(ids.inc, ids.get);
    }

    #[test]
    fn test_atom_ids_are_distinct() {
        let table = MockAtomTable::new();
        let _ = init_atoms(&table);

        let ids = AtomIds::load(&table).unwrap();

        // All atom IDs should be unique
        let mut atom_ids = vec![
            ids.worker,
            ids.inc,
            ids.get,
            ids.ok,
            ids.error,
            ids.badarg,
            ids.internal_error,
        ];
        let len_before = atom_ids.len();
        atom_ids.sort();
        atom_ids.dedup();
        let len_after = atom_ids.len();

        assert_eq!(len_before, len_after, "Atom IDs are not unique!");
    }
}
