//! Generated Worker NIF dispatcher
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! DO NOT EDIT: changes will be overwritten
//!
//! Receives messages from AtomVM, dispatches to Rust handlers, returns results

use avmnif::term::{Term, TermValue, NifResult};
use avmnif::atom::AtomTableOps;
use crate::generated::atoms::*;
use crate::generated::worker_protocol::*;

/// Worker actor state (holds data across messages)
pub struct WorkerState {
    pub count: i64,
}

impl WorkerState {
    /// Create initial state
    pub fn new() -> Self {
        WorkerState { count: 0 }
    }

    /// Handler: inc(by)
    pub fn handle_inc(&mut self, by: i64) -> WorkerReply {
        self.count += by;
        WorkerReply::IncReply(self.count)
    }

    /// Handler: get()
    pub fn handle_get(&self) -> WorkerReply {
        WorkerReply::GetReply(self.count)
    }
}

/// Main dispatcher: routes message to handler
///
/// Called from AtomVM NIF:
///   kgc_nif:dispatch(ActorId, Message) -> Reply
///
/// Receives decoded WorkerMsg, executes handler, returns encoded reply
pub fn dispatch(
    state: &mut WorkerState,
    msg: WorkerMsg,
    table: &impl AtomTableOps,
) -> Result<WorkerReply, WorkerError> {
    match msg {
        WorkerMsg::Inc(by) => {
            let reply = state.handle_inc(by);
            Ok(reply)
        }
        WorkerMsg::Get => {
            let reply = state.handle_get();
            Ok(reply)
        }
    }
}

/// Full message handling pipeline:
/// 1. Decode term → WorkerMsg
/// 2. Dispatch to handler
/// 3. Encode reply → term
pub fn handle_term_message(
    state: &mut WorkerState,
    msg_term: &TermValue,
    table: &impl AtomTableOps,
) -> Result<TermValue, TermValue> {
    // Decode message
    let msg = match decode_worker_msg(msg_term, table) {
        Ok(m) => m,
        Err(e) => {
            // Return error term
            let err = WorkerError::BadArg(e);
            return Err(encode_worker_error(&err, table).unwrap_or(TermValue::Invalid));
        }
    };

    // Dispatch to handler
    let reply = match dispatch(state, msg, table) {
        Ok(r) => r,
        Err(e) => {
            return Err(encode_worker_error(&e, table).unwrap_or(TermValue::Invalid));
        }
    };

    // Encode reply
    encode_worker_reply(&reply, table)
        .map_err(|_| TermValue::Invalid)
}

#[cfg(test)]
mod tests {
    use super::*;
    use avmnif::testing::*;

    #[test]
    fn test_worker_state_creation() {
        let state = WorkerState::new();
        assert_eq!(state.count, 0);
    }

    #[test]
    fn test_worker_handle_inc() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        let reply = state.handle_inc(5);
        assert_eq!(state.count, 5);
        assert!(matches!(reply, WorkerReply::IncReply(5)));
    }

    #[test]
    fn test_worker_handle_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();
        state.count = 42;

        let reply = state.handle_get();
        assert!(matches!(reply, WorkerReply::GetReply(42)));
    }

    #[test]
    fn test_worker_inc_then_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        state.handle_inc(10);
        let reply = state.handle_get();

        assert!(matches!(reply, WorkerReply::GetReply(10)));
    }

    #[test]
    fn test_dispatch_inc() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        let msg = WorkerMsg::Inc(7);
        let result = dispatch(&mut state, msg, &table);

        assert!(result.is_ok());
        assert_eq!(state.count, 7);
    }

    #[test]
    fn test_dispatch_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();
        state.count = 99;

        let msg = WorkerMsg::Get;
        let result = dispatch(&mut state, msg, &table);

        assert!(result.is_ok());
    }

    #[test]
    fn test_handle_term_message_inc() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        // Build term: {inc, 5}
        let inc_atom = table.ensure_atom_str("inc").unwrap();
        let msg_term = TermValue::tuple(vec![
            TermValue::atom(inc_atom),
            TermValue::int(5),
        ]);

        let result = handle_term_message(&mut state, &msg_term, &table);
        assert!(result.is_ok());
        assert_eq!(state.count, 5);
    }

    #[test]
    fn test_multi_hop_inc_get() {
        let table = MockAtomTable::new();
        let mut state = WorkerState::new();

        for i in 1..=5 {
            let inc_atom = table.ensure_atom_str("inc").unwrap();
            let msg_term = TermValue::tuple(vec![
                TermValue::atom(inc_atom),
                TermValue::int(i),
            ]);

            let result = handle_term_message(&mut state, &msg_term, &table);
            assert!(result.is_ok());
        }

        // Verify final state
        assert_eq!(state.count, 1 + 2 + 3 + 4 + 5); // 15
    }
}
