//! Generated Worker message protocol
//!
//! Auto-generated by ggen from ontology/worker.ttl
//! DO NOT EDIT: changes will be overwritten
//!
//! Maps Erlang messages ↔ Rust types with full codec support

use avmnif::term::{Term, TermValue};
use avmnif::atom::AtomTableOps;

/// Worker actor messages (auto-generated from ontology)
#[derive(Debug, Clone)]
pub enum WorkerMsg {
    /// Inc(by: i64) -> reply: i64
    /// Increment counter by given amount, return new value
    Inc(i64),

    /// Get() -> reply: i64
    /// Return current counter value
    Get,
}

/// Worker reply types (auto-generated from ontology)
#[derive(Debug, Clone)]
pub enum WorkerReply {
    /// Inc success: new counter value
    IncReply(i64),

    /// Get success: counter value
    GetReply(i64),
}

/// Errors that can occur in Worker handler
#[derive(Debug, Clone)]
pub enum WorkerError {
    BadArg(String),
    Internal(String),
}

/// Codec: Erlang term → WorkerMsg
/// Maps `{inc, N}` and `get` to Rust enum
pub fn decode_worker_msg<T: AtomTableOps>(
    term: &TermValue,
    table: &T,
) -> Result<WorkerMsg, String> {
    // Pattern: {inc, N} where N is integer
    if let Some(elems) = term.as_tuple() {
        if elems.len() == 2 {
            if let (Some(tag), Some(n)) = (elems[0].as_atom(), elems[1].as_int()) {
                let inc_atom = table.ensure_atom_str("inc")
                    .map_err(|_| "atom table error".to_string())?;

                if tag == inc_atom {
                    return Ok(WorkerMsg::Inc(n as i64));
                }
            }
        }
    }

    // Pattern: atom `get`
    if let Some(tag) = term.as_atom() {
        let get_atom = table.ensure_atom_str("get")
            .map_err(|_| "atom table error".to_string())?;

        if tag == get_atom {
            return Ok(WorkerMsg::Get);
        }
    }

    Err(format!("Cannot decode WorkerMsg from {:?}", term))
}

/// Codec: WorkerReply → Erlang term
/// Maps Rust replies back to atoms/tuples for AtomVM
pub fn encode_worker_reply<T: AtomTableOps>(
    reply: &WorkerReply,
    table: &T,
) -> Result<TermValue, String> {
    match reply {
        WorkerReply::IncReply(value) => {
            // Reply: {ok, Value}
            let ok_atom = table.ensure_atom_str("ok")
                .map_err(|_| "atom table error".to_string())?;
            Ok(TermValue::tuple(vec![
                TermValue::atom(ok_atom),
                TermValue::int(*value as i32),
            ]))
        }
        WorkerReply::GetReply(value) => {
            // Reply: {ok, Value}
            let ok_atom = table.ensure_atom_str("ok")
                .map_err(|_| "atom table error".to_string())?;
            Ok(TermValue::tuple(vec![
                TermValue::atom(ok_atom),
                TermValue::int(*value as i32),
            ]))
        }
    }
}

/// Codec: WorkerError → Erlang error term
pub fn encode_worker_error<T: AtomTableOps>(
    error: &WorkerError,
    table: &T,
) -> Result<TermValue, String> {
    match error {
        WorkerError::BadArg(reason) => {
            let error_atom = table.ensure_atom_str("error")
                .map_err(|_| "atom table error".to_string())?;
            let badarg_atom = table.ensure_atom_str("badarg")
                .map_err(|_| "atom table error".to_string())?;

            Ok(TermValue::tuple(vec![
                error_atom_enum,
                badarg_atom,
            ]))
        }
        WorkerError::Internal(reason) => {
            let error_atom = table.ensure_atom_str("error")
                .map_err(|_| "atom table error".to_string())?;
            let internal_atom = table.ensure_atom_str("internal_error")
                .map_err(|_| "atom table error".to_string())?;

            Ok(TermValue::tuple(vec![
                error_atom,
                internal_atom,
            ]))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use avmnif::testing::*;

    #[test]
    fn test_decode_inc_msg() {
        let table = MockAtomTable::new();

        // Build term: {inc, 42}
        let inc_atom = table.ensure_atom_str("inc").unwrap();
        let term = TermValue::tuple(vec![
            TermValue::atom(inc_atom),
            TermValue::int(42),
        ]);

        let msg = decode_worker_msg(&term, &table);
        assert!(msg.is_ok());

        if let Ok(WorkerMsg::Inc(n)) = msg {
            assert_eq!(n, 42);
        }
    }

    #[test]
    fn test_decode_get_msg() {
        let table = MockAtomTable::new();

        // Build term: atom `get`
        let get_atom = table.ensure_atom_str("get").unwrap();
        let term = TermValue::atom(get_atom);

        let msg = decode_worker_msg(&term, &table);
        assert!(msg.is_ok());
        assert!(matches!(msg.unwrap(), WorkerMsg::Get));
    }

    #[test]
    fn test_encode_inc_reply() {
        let table = MockAtomTable::new();

        let reply = WorkerReply::IncReply(99);
        let term = encode_worker_reply(&reply, &table);
        assert!(term.is_ok());

        let t = term.unwrap();
        assert!(t.as_tuple().is_some());
    }

    #[test]
    fn test_encode_get_reply() {
        let table = MockAtomTable::new();

        let reply = WorkerReply::GetReply(42);
        let term = encode_worker_reply(&reply, &table);
        assert!(term.is_ok());

        let t = term.unwrap();
        assert!(t.as_tuple().is_some());
    }
}
