// Generated by ggen from {{ ontology_file }}
// DO NOT EDIT - This file is auto-generated from RDF ontologies
// Generated at: {{ generation_time }}

use avmnif_rs::{
    atom::AtomTableOps,
    context::Context,
    term::{Term, TermValue, NifError, NifResult},
};

{% for nif in nif_functions %}
/// {{ nif.label }}
///
/// {{ nif.description }}
///
{%- for param in nif.parameters %}
/// # Arguments
///
/// * `{{ param.name }}` - {{ param.doc }}
{%- endfor %}
///
/// # Returns
///
/// Returns a term of type {{ nif.returnType }}.
{%- if nif.canFail %}
///
/// # Errors
///
/// Returns error if validation fails or computation overflows.
{%- endif %}
pub fn {{ nif.rustName }}(
    _ctx: &mut Context,
    args: &[Term],
) -> NifResult<Term> {
    // Validate arity
    if args.len() != {{ nif.arity }} {
        return Err(NifError::BadArity);
    }

    // Convert arguments from FFI terms to Rust values
    {% for param in nif.parameters -%}
    let {{ param.name }} = args[{{ param.index }}].to_value()?;
    {% endfor %}

    // TODO: Implement the actual computation
    // This is a generated stub - replace with your logic

    {% if nif.returnType == "SmallInt" -%}
    // Placeholder: return 0
    let result = TermValue::int(0);
    {% elif nif.returnType == "Atom" -%}
    // Placeholder: return :ok atom
    // In real implementation, you'd create the atom properly with a table
    let result = TermValue::int(0); // TODO: Fix this
    {% elif nif.returnType == "List" -%}
    // Placeholder: return empty list
    let result = TermValue::list(vec![]);
    {% else -%}
    // Placeholder for {{ nif.returnType }}
    let result = TermValue::int(0);
    {% endif %}

    // Convert result back to FFI term
    Ok(Term::from_value(result, &mut _ctx.heap)?)
}

{% endfor %}

// ─────────────────────────────────────────────────────────────────
// Generated Module Tests
// ─────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use avmnif_rs::testing::*;

    {% for nif in nif_functions %}
    #[test]
    fn test_{{ nif.rustName }}_basic() {
        // TODO: Implement test for {{ nif.label }}
        // Example test structure:
        // let table = MockAtomTable::new();
        // let mut ctx = create_test_context();
        // let args = vec![/* ... */];
        // let result = {{ nif.rustName }}(&mut ctx, &args);
        // assert!(result.is_ok());
    }

    {% endfor %}
}
